# k8s Architecture

* [Declarative Configuration](#declarative-configuration)
* [Reconciliation or Controllers](#reconciliation-or-controllers)
* [Implicit or Dynamic Grouping](#implicit-or-dynamic-grouping)
* [Unix Philosophy of Many Components](#unix-philosophy-of-many-components)
* [API-Driven Interactions](#api-driven-interactions)

### Declarative Configuration
The notion of declarative configuration—when a user declares a desired state of the world to produce a result—is one of the primary drivers behind the development of Kubernetes. For example, a user might say to Kubernetes, “I want there to be five replicas of my web server running at all times.” Kubernetes, in turn, takes that declarative statement and takes responsibility for ensuring that it is true. Unfortunately, Kubernetes is unable to understand natural language instructions and so that declaration is actually in the form of a structured YAML or JSON document.

Declarative configuration differs from imperative configuration in which users take a series of direct actions (e.g., creating each of the five replicas that they want to have up and running). Imperative actions are often simpler to understand—one can simply say, “run this,” instead of using a more complex declarative syntax. However, the power of the declarative approach is that you are giving the system more than a sequence of instructions—you are giving it a declaration of your desired state. Because Kubernetes understands your desired state, it can take autonomous action, independent of user interaction. This means that it can implement automatic selfcorrecting and self-healing behaviors. For a developer, this is critical, since it means that the system can fix itself without waking you up in the middle of the night.

### Reconciliation or Controllers
To achieve these self-healing or self-correcting behaviors, Kubernetes is structured based on a large number of independent reconciliation or control loops. When designing a system like Kubernetes, there are generally two different approaches that you can take—a monolithic state-based approach or a decentralized controller–based approach.

In monolithic system design, the system is aware of the entire state of the world and uses this complete view to move everything forward in a coordinated fashion. This can be very attractive, since the operation of the system is centralized and thus easier to understand. The problem with the monolithic approach is that it is not particularly stable. If anything unexpected happens, the entire system can come crashing down.

Kubernetes takes an alternative decentralized approach in its design. Instead of a single monolithic controller, Kubernetes is composed of a large number of controllers, each performing its own independent reconciliation loop. Each individual loop is only responsible for a small piece of the system (e.g., updating the list of endpoints for a particular load balancer), and each small controller is wholly unaware of the rest of the world. This focus on a small problem and the corresponding ignorance of the broader state of the world makes the entire system significantly more stable. Each controller is largely independent of all others and thus unaffected by problems or changes unrelated to itself.

### Implicit or Dynamic Grouping
Whether it is grouping together a set of replicas or identifying the backends for a load balancer, there are numerous times in the implementation of Kubernetes when it is necessary to identify a set of things. When grouping things together into a set, there are two possible approaches—explicit/static or implicit/dynamic grouping. With static grouping, every group is defined by a concrete list (e.g., “The members of my team are Alice, Bob, and Carol.”). The list explicitly calls out the name of each member of the group, and the list is static—that is, the membership doesn’t change unless the list itself changes. Much like a monolithic approach to design, this static grouping is easily understandable. To know who is in a group, one simply has to read the list. The challenge with static grouping is that it is inflexible—it cannot respond to a dynamically changing world. Hopefully, at this point, you know that Kubernetes uses a more dynamic approach to grouping. In Kubernetes, groups are implicitly defined.

The alternative to explicit, static groups is implicit, dynamic groups. With implicit groups, instead of the list of members, the group is defined by a statement like, “The members of my team are the people wearing orange.” This group is implicitly defined. Nowhere in the definition of the group are the members defined; instead, they are implied by evaluating the group definition against a set of people who are present. Because the set of people who are present can always change, the membership of the group is likewise dynamic and changing. Although this can introduce complexity, because of the second step (in the example case, looking for people wearing orange), it is also significantly more flexible and stable, and it can handle a changing environment without requiring constant adjustments to static lists.

In Kubernetes, this implicit grouping is achieved via labels and label queries or label selectors. Every API object in Kubernetes can have an arbitrary number of key/value pairs called “labels” that are associated with the object. You can then use a label query or label selector to identify a set of objects that matches that query.

### Unix Philosophy of Many Components
Kubernetes ascribes to the general Unix philosophy of modularity and of small pieces that do their jobs well. Kubernetes is not a single monolithic application that implements all of the various functionality in a single binary. Instead, it is a collection of different applications that all work together, largely ignorant of each other, to implement the overall system known as Kubernetes. Even when there is a binary (e.g., the controller manager) that groups together a large number of different functions, those functions are held almost entirely independently from each other in that binary. They are compiled together largely to make the task of deploying and managing Kubernetes easier, not because of any tight binding between the components.

### API-Driven Interactions
All interaction between components is driven through a centralized API surface area. An important corollary of this design is that the API that the components use is the exact same API used by every other cluster user. This has two important consequences for Kubernetes. The first is that no part of the system is more privileged or has more direct access to internals than any other. Indeed, with the exception of the API server that implements the API, no one has access to the internals at all. Thus, every component can be swapped for an alternative implementation, and new functionality can be added without rearchitecting the core components.

The API-driven interactions incentivize a system to be stably designed in the presence of version skew. When you roll out a distributed system to a grouping of machines, for a period of time, you will have both the older version and the new version of the software running simultaneously. If you haven’t planned directly for this version skew, the unplanned (and often untested) interactions between old and new versions can cause instability and outages. Because in Kubernetes everything is mediated through the API and the API provides strongly defined API versions and conversion between different version numbers, the problems of version skew can largely be avoided. In reality, though, occasional problems can still crop up, and version skew and upgrade testing is an important part of Kubernetes release qualification.