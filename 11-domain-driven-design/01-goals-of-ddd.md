# The basic goals of domain-driven development

In domain-driven design, there are three basic uses that determine the choice of a model.
1. **The model dictates the form of the design of the heart of the software.** It is the intimate link between the model and the implementation that makes the model relevant and ensures that the analysis that went into it applies to the final product, a running program. This binding of model and implementation also helps maintenance and continuing development because the code can be interpreted based on understanding the model;
2. **The model is the backbone of a language used by all team members.** Because of the binding of model and implementation, developers can talk about the program in this language. They can communicate with domain experts without translation. And because the language is based on the model, our natural linguistic abilities can be turned to refining the model itself;
3. **The model is distilled knowledge.** The model is the teamâ€™s agreed-upon way of structuring domain knowledge, and distinguishing the elements of most interest. A model captures how we choose to think about the domain as we select terms, break down concepts, and relate them. The shared language allows effective collaboration of developers and domain experts to wrestle information into this form. The binding of model and implementation ensures means that experience with early versions of the software are also valid feedback into the modeling process;

Business activities and rules are as central to a domain as are the entities involved, and any domain will have various categories of concepts. Knowledge crunching yields models that reflect this kind of insight. In parallel with model changes, developers refactor the implementation to express the model, and giving the application use of that knowledge.

The domain model can be the core of a common language for a software project. The model is the set of concepts built up in the heads of people on the project, with terms and relationships that reflect domain insight.

To create a supple, knowledge-rich design calls for a versatile, shared team language, and a lively experimentation with language that seldom happens on software projects. The core of such a language comes from the domain model. The **UBIQUITOUS LANGUAGE** carries knowledge in a dynamic form.

It is a serious problem when the language used on a project is fractured. Domain experts use their jargon while technical team members have their own language tuned for discussing the domain in terms of design. Translation blunts communication and makes knowledge crunching anemic. Yet none of these dialects can be a common language because none serves all needs. The terminology of day-to-day discussions is disconnected from the terminology embedded in the code (ultimately the most important product of a software project). Even the same person uses different language in speech and in writing, and so the most incisive expressions of the domain often emerge in a transient form that is never captured in the code or even in writing.

Use the model as the backbone of a language. Commit the team to using that language relentlessly in all communication within the team and in the code. Use the same language in diagrams, writing, and, especially speech. Iron out difficulties by experimenting with alternative expressions, which reflect alternative models. Then refactor the code, renaming classes, methods and modules to conform to the new model. Resolve confusion over terms in conversation, in just the way we converge on agreed meaning of ordinary words. Domain experts object to terms or structures that are awkward or inadequate to convey domain understanding, while developers watch for ambiguity or inconsistency that will trip up design.

The vital detail about the design is captured in the code.

Domain-driven design puts a model to work to solve problems for an application. Through knowledge crunching, a team distills a torrent of chaotic information into a practical model. A **MODEL-DRIVEN DESIGN** intimately connects the model and the implementation. The **UBIQUITOUS LANGUAGE** is the channel for all that information to flow between developers, domain experts and the software. The result is software that provides rich functionality based on a fundamental understanding of the core domain.
